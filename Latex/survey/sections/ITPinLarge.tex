\section{Challenges in Large-Scale Formal Verification}
\label{sec:ITPinLarge}

One important application of iterative theorem proving systems is formal verification of large complex systems. An increasing number of large scale system verification projects has been carried out in recent decades and has appeared as published case studies in literature. One of the successfully commercialized verification projects is the certified C compiler, CompCert~\cite{Leroy_2006, Leroy_2009}, for which Leory's work~\cite{Leroy_2006} received the Test of the Time award in POPL (Symposium on Principles of Programming Languages) 2016 and was noted as a groundbreaking contribution in demonstrating the feasibility of interactive theorem prover~\cite{ACM_SIGPLAN_2016}. It's indeed a groundbreaking achievement even in terms of effort, given the scale of the project with 350,000 lines of Coq code along with state of the art of ITP systems at that time. Having tens of thousands of lines of code is not at all unusual in large proof development, irrespective of the ITP systems used in the project. Certification of seL4 Operating System Kernel by Klein \emph{et. al.}~\cite{Klein_et_al_2009} produced about 480,000 lines of code in Isabelle/HOL~\cite{Klein_et_al_2014}, Coq correctness proofs of an Raft distributed consensus protocol~\cite{Ongaro_et_al_2014} comprises of 50k lines in total~\cite{Woos_et_al_2016}. However, hurdles behind these verification works are not only due to the size. The biggest challenge comes from the complexity of the underlying system such as non-trivial concurrent OS kernel~\cite{Gu_et_al_2016}. Industrial design specification is often performance-oriented, thus imprecise in nature, which impedes the creation of clear and elegant abstract specifications needed for formal verification~\cite{Kaivola_et_al_2003}. Sometimes verification even gets carried out as part of an active, hence evolving development project. Interactive theorem proving is itself hard, and together with the issues mentioned above, it takes multiple persons years of effort for a single verification project~\cite{Delaware_et_al_2011}. Proof engineers and researchers involved in many of these large-scale projects later reported they could have saved lots of time if, from the beginning of proof development, they followed some schemes that facilitate adaptability, well-organization and reusability of proofs~\cite{Curzon_1995, Kaivola_et_al_2003, Woos_et_al_2016}. In fact, these attributes of proofs have been repeatedly identified by researchers that promote maintainability and efficiency i.e. the two main challenges in large scale development. Klein \emph{et. al.}~\cite{Klein_et_al_2014} also provides a picture of how often they needed to adapt their proofs to changes and how bad the maintenance cost was for that at the time of their sel4 OS kernel verification~\cite{Klein_et_al_2009}. 17\% of their total proof effort was just to reverify their system in response to fundamental changes in existing features of sel4 kernel. This is only one of the four kinds of changes they encountered. To be noted here, this verification project was carried out as part of the development of the kernel itself. 

Not surprisingly, many of these large projects were followed up with work on methodologies for maintainable and efficient development. Although these methodologies were initially devised to be used in their respective projects, in the follow-up papers, they tried to generalize their solutions to be used irrespective of domains\cite{Curzon_1995, Delaware_et_al_2011, Kaivola_et_al_2003, Woos_et_al_2016}. Apart from these, some notable works have been done on proof reusability. However, even with conscious attention to maintainability during proof design and development, some unforeseen or unpredictable changes are bound to happen. Adapting proofs in large scale development to these changes has been identified as another challenging aspect of large-scale proof engineering. Researcher have also begun working on refactoring and repairing techniques to incorporate these changes efficiently. Therefore, research on maintainability and efficiency issues of large-scale proof development can be categorized as proactive measures to be followed during proof design and development and reactive measures to adapt proofs to changes anytime. Following two sections address them respectively.

%these solutions are closely related to the associated project insinuated from the insight they gained from experience and difficulties they encountered during the development process, the general goal across these papers is to analyze and tackle issues associated with scaling~
%Apart from the works mentioned above on tackling issues with large scale development, there is also a substantial amount of impactful work in mechanizing metatheory. Proving properties of programming languages often need a different set of tools in ITPs such as the representation of binders or complex inductions ~\cite{Aydemir_et_al_2005}. 

%Key challenges in this domain identified by the POPLMark challenge are the representation of binders, complex inductions, experimentation, and reuse of components.

% ** In the following two sections, I am going to categorize the research on these practical aspects of theorem proving in two areas - a) design strategies to be followed during proof development both for scalability and mechanized metatheory, b) refactoring and repair techniques to handle changes over time. Then, I'll give a summary of the methods that have been integrated into tools or supported from the library level.

%From a high level perspective, proof engineering research can be categorized into two kinds - a) design strategies to be followed during proof development, b) refactoring and repair techniques to handle changes over time. 

%In the following sections, I am going to categorize the research on these practical aspects of theorem proving in two areas - strategies and framework for proof development and techniques and methods for proof maintenance over time. Then, I will give an overview of existing tooling and library level support for both of them.
%Some of these techniques are being integrated in tools as well.

%Apart from all these works on tackling issues with large scale development, there is one particular domain where interactive theorem has not only created a large practical impact also importance of application in that domain led to including features in ITPs' core language. As you have already guessed from the context or section title, I am talking about mechanized metathory. Some ideas from these domain can even be generalized to other domains. Considerable amount of influential works in this domain demonstrates practical aspects and impacts of ITPs, thus demands to be included in this survey. 

%Reflecting real systems and its properties accurately of paramount importance for the success of the task at hand.

%Without efficient strategies to facilitate proofs' adaptability, modifiability, robustness, reuse during proof development along with clever techniques to support its maintenance over time, interactive theorem proving would not be able to make as much impact as compared to its usefulness [describe usefulness in introduction]. Therefore, proof engineering research have been expanded to find methodologies and design principles handling the challenges in large scale development and some of these are being integrated in tools as well.
%[ don't need here: automation faciliates above feature : Moreover, a well-designed theorem along with attributes mentioned above should also make use of as much automation as required to keep programmer from reinventing the wheels and focusing on more complex parts that indeed require human guided strategy to solve.]
%Not surprisingly, a handful of  research that has been done on these aspects of proof engineering, was part or follow-up work of some large verification projects~\cite{}. Although these works stem from the experience of respective project concentrating on finding solution for the difficulties they faced during proof development stage, the general goal across these papers is to analyze and tackle issues associated with scaling. As a result, nearly all of these methods can be used irrespective of domains~\cite{woos 16, kaivola}. 
%However, there have been some works targeting issues in mechanizing metathory which demand specialized solutions like binder, ..... ~\cite{POPLmark challenge}. Here, I am limiting the scope of this work given the time constraint ignoring numerous other domain specialized methods in practice and even in mechanized metatheory only focusing research on framework for structuring. 
% In the following sections, I am going to categorize the research on these practical aspects of theorem proving in three areas - strategies and framework for proof development, techniques and methods for proof maintenance over time and existing tooling support for both of these aspects.
%\point {eg1: data evolution}
%\textbf{Context 1: schema evolution.}

%\emph{Every time the database evolves, a new ``variant'' is created.}

% The Mizar mathematical library is probably the most comprehensive formalization eﬀort, but its declarative style makes it hard to employ proof search, and its source code is not freely available. Like Coq and HOL Light, also Isabelle [14] was used for major formalization eﬀorts, such as the formalization of the seL4 microkernel [16]. We are not awareofacomprehensivecoverageoffundamentalmathematics in Isabelle, HOL4, or Lean. 
